# Структуры данных. Работа в VS Code со структурами данных «бинарная_биноминальная куча/куча Фибоначчи/хеш-таблицы» (Панченко Виктория Вадимовна, УИБО-10-24)

## 1. Бинарная и биноминальная куча

### 1.1 Бинарная куча
Бинарная куча — это структура данных, представляющая собой полное бинарное дерево, которое удовлетворяет свойству кучи. Это одна из самых эффективных и популярных реализаций очереди с приоритетами.

##### Основные свойства
1. Структура полного бинарного дерева
Все уровни заполнены, кроме, возможно, последнего

Последний уровень заполняется слева направо

Высота дерева: O(log n)

2. Свойство кучи
Min-Heap: ключ каждого узла ≤ ключей его детей
Max-Heap: ключ каждого узла ≥ ключей его детей

#### 1.1.1 Бинарная куча в Python

Для работы с бинарными кучами используется модуль heapq. Он реализует минимальную кучу, где родительский элемент всегда меньше или равен дочерним.

```
import heapq

numbers_list = [8, 3, 5, 1, 6, 2, 4, 7] # создание списка, который в дальнейшем превратится в кучу
heapq.heapify(numbers_list) # превращение списка в кучу
heapq.heappush(numbers_list, 0) # добавить новый элемент в кучу
min_value = heapq.heappop(numbers_list) # извлечь минимальный элемент из кучи
```
Это реализация минимальной кучи, которая по умолчанию создается при использовании библиотеки heapq. 
Синтаксис довольно прост, но за это приходится расплачиваться ограниченными возможностями.
Реализация максимальной кучи находится в файле task_13.py (используется библиотека heapq с отрицательными значениями)

#### 1.1.2 Бинарная куча в C++

Готовая реализация бинарной кучи есть в STL (priority_queue). Можно использовать и как min-heap и как max-heap.

```
int main(){
  priority_queue<int> pq; // Создает бинарную кучу типа max-heap по умолчанию
  pq.push(30); // Вставка элемента
  while (!pq.empty()) // Проверка кучи на пустоту
  {
    cout << pq.pop() << " "; // Удаление элемента. Самый большой элемент выходит первым.
  }
}
```

Реализация бинарной кучи типа min-heap через собственный класс находится в файле min_heap.cpp. Для создания такой структуры данных использовался STD::vector
По сравнению с другими языками программирования - наиболее быстрая производительность.

#### 1.1.3 Бинарная куча на Java

В Java есть встроенная реализация через класс PriorityQueue
```
import java.util.PriorityQueue;

public class MinHeapExample {
    public static void main(String[] args) {
        // Создание Min-Heap (по умолчанию)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        
        // Добавление элементов
        minHeap.add(5);
        minHeap.add(3);
        minHeap.add(8);
        minHeap.add(1);
        minHeap.add(10);
        
        System.out.println("Min-Heap: " + minHeap);
        System.out.println("Минимальный элемент: " + minHeap.peek());
        
        // Извлечение элементов в порядке возрастания
        System.out.print("Извлечение элементов: ");
        while (!minHeap.isEmpty()) {
            System.out.print(minHeap.poll() + " ");
        }
        // Output: 1 3 5 8 10
    }
}
```

По умолчанию она реализует бинарную кучу типа min-heap. Эта реализация обладает наибольшим функционалам из всех представленных ЯП, а также поддерживает компараторы для кастомизации.

#### 1.1.4 Вывод

В Python наиболее простой синтаксис для реализации бинарной кучи, но за это приходится платить производительностью и кастомизацией.
В C++ самый сложный синтаксис, но наибольшая производительность.
В Java наибольший функционал из всех представленных языков программирования, а также реализация бинарной кучи поддерживает компараторы для кастомизации

### 1.2 Биноминальная куча

Биномиальная куча — это структура данных, представляющая собой набор биномиальных деревьев, которые удовлетворяют свойству кучи. 
Это эффективная реализация очереди с приоритетами, которая поддерживает быстрые операции объединения. Каждое биноминальное дерево порядка k имеет 2^k узлов. 
##### Структура узла
Каждый узел содержит:
- Ключ (значение)
- Степень (количество дочерних узлов)
- Указатели: родитель, ребенок, брат
- Основные операции: объединение куч, вставка, извлечение минимума.

##### Основные операции
- Вставка
- Поиск минимума
- Извлечение минимума
- Слияние двух куч
- Просеивание вверх (уменьшение ключа)
- Удаление

#### 1.2.1 Биноминальная куча на Python
Встроенной в стандартную библиотеку реализации нет.
Реализация биноминальной кучи находится в файле task_13.py

#### 1.2.2 Биноминальная куча на C++
Встроенной в стандартную библиотеку реализации нет.
Реализация биноминальной кучи находится в файле binominal_heap.cpp

#### 1.2.3 Биноминальная куча на Java
Встроенной в стандартную библиотеку реализации нет.
Реализация биноминальной кучи находится в файле binominal_heap.java

#### 1.2.4 Вывод
Для такой сложной структуры данных в данных языках программирования отсутствует стандартная реализация. Для большинства практических задач достаточно бинарной кучи, а реализация биноминальной кучи значительно сложнее.

## 2. Структура данных куча Фибоначчи

Куча Фибоначчи — это структура данных, используемая для реализации очередей с приоритетами. Она имеет амортизированно хорошее время выполнения для операций вставки, поиска минимума, объединения и уменьшения ключа, а также извлечения минимума.
##### Основные особенности:
- Состоит из набора деревьев, удовлетворяющих свойству min-heap.
- Деревья в куче являются деревьями с произвольным количеством потомков и имеют структуру, которая позволяет эффективно выполнять операции. Список операций такой же как и в биноминальной куче.

### 2.1 Куча Фибоначчи в Python
Встроенной в стандартную библиотеку реализации нет.

Типовая реализация находится в файле fib_heap.py. Для простоты нет некоторых операций (decreaseKey, delete, cascading cut)

### 2.2 Куча Фибоначчи в C++
Встроенной в стандартную библиотеку реализации нет.

Типовая реализация находится в файле fib_heap.cpp. Для простоты нет некоторых операций (decreaseKey, delete, cascading cut)

### 2.3 Куча Фибоначчи в Java
Встроенной в стандартную библиотеку реализации нет.

Типовая реализация находится в файле fib_heap.java. Для простоты нет некоторых операций (decreaseKey, delete, cascading cut)

### 2.4 Вывод по куче Фибоначчи
Для этой структуры данных в данных языках программирования отсутствует стандартная реализация. Представленные реализации демонстрируют общий подход к этой структуре данных.

## 3. Структура данных hashmap (хэш-таблица)
Хэш-таблица это структура данных, реализующая интерфейс ассоциативного массива. В отличие от деревьев поиска, реализующих тот же интерфейс, обеспечивают меньшее время отклика в среднем. Представляет собой эффективную структуру данных для реализации словарей, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.

### 3.1 Хэш-таблица в Python
Реализацией хэш-таблицы в Python является встроенная структура данных dict (cловарь). Это ассоциативный массив, который хранит пары ключ-значение. Ключи должны быть хешируемыми объектами (то есть иметь метод __hash__ и метод __eq__ для сравнения).
```
d = {'a': 1, 'b': 2, 'c': 3} # Создание словаря
d['d'] = 4 # Вставка элемента
value = d['a'] # Поиск элемента
del d['b'] # Удаление элемента

```

### 3.2 Хэш-таблица в C++

В контейнере STL присутсвует несколько разновидностей реализации хэш-таблицы: std::unordered_map и std::unordered_set. 

Рассмотрим std::unordered_map (так как отличие от unordered_set только в том, что в unordered_set хранятся уникальные значения)
std::unordered_map - это ассоциативный контейнер, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление элементов имеют среднюю постоянную сложность.

Пример использования std::unordered_map находится в файле hash.cpp

#### Внутреннее устройство
Хэш-таблицы в C++ стандартной библиотеке обычно реализуют:
- Динамический массив бакетов: каждый бакет содержит список элементов (цепочка для разрешения коллизий).
- Хэш-функция: преобразует ключ в индекс бакета. По умолчанию используется std::hash<Key>.
- Функция равенства: по умолчанию std::equal_to<Key>, чтобы сравнивать ключи.

##### Процесс вставки:
- Вычисляется хэш ключа.
- Находится индекс бакета: index = hash(key) % bucket_count.

Если в бакете уже есть элементы, то происходит проверка на коллизии. Если ключ уже существует (сравнивается с помощью функции равенства), то значение обновляется. Иначе элемент добавляется в цепочку.

##### Процесс поиска:
- Вычисляется хэш ключа.
- Находится индекс бакета.
Происходит линейный поиск по цепочке в бакете.

### 3.3 Хэш-таблица в Java

Хэш-таблица в Java реализована в нескольких классах, но наиболее часто используемой реализацией является класс HashMap.
HashMap в Java состоит из массива бакетов (корзин), где каждый бакет представляет собой связный список (или дерево, если список становится слишком длинным) элементов. Каждый элемент — это объект класса Node (или TreeNode для дерева), который содержит:
- ключ (key)
- значение (value)
- хэш ключа (hash)
- ссылку на следующий узел (next)

Пример использования этой структуры данных есть в файле hash.java

### 3.4 Вывод по хэш-таблице

#### Ключевые отличия хэш-таблиц в Python, Java и C++
##### 🐍 Python (dict)
Структура: Компактная хэш-таблица с раздельными массивами

python
# Python 3.6+
```
entries = [{"hash": h1, "key": k1, "value": v1}, 
           {"hash": h2, "key": k2, "value": v2}]
```
Ключевые особенности:
- ✅ Сохраняет порядок вставки (с Python 3.7)
- ✅ Открытая адресация для разрешения коллизий
- ✅ Псевдослучайное пробирование (i² + i)/2
- ✅ Динамическое расширение с коэффициентом ~2/3
- ✅ Встроенная оптимизация для строковых ключей

##### ☕ Java (HashMap)
Структура: Массив бакетов + цепочки/деревья

```
Node<K,V>[] table = new Node[16];
// При коллизиях: связный список → красно-черное дерево (Java 8+)
```
Ключевые особенности:

- ❌ Не сохраняет порядок (используйте LinkedHashMap)
- ✅ Метод цепочек с преобразованием в деревья
- ✅ Порог дерева - цепочка из 8+ элементов
- ✅ Load factor 0.75 по умолчанию
- ✅ Битовая маска (n-1) & hash вместо модуля

* load factor - это среднее количество элементов на бакет

⚡ C++ (std::unordered_map)
Структура: Классическая хэш-таблица с цепочками

```
std::vector<std::list<std::pair<Key, Value>>> buckets;
// или std::vector<std::forward_list<...>>
```
Ключевые особенности:

- ❌ Не сохраняет порядок
- ✅ Метод цепочек (обычно связные списки)
- ✅ Максимальный load factor настраивается
- ✅ Раздельные чанки для каждого бакета
- ✅ Требует хэш-функцию и компаратор

* load factor - это среднее количество элементов на бакет. Когда load_factor > 1 - происходит рехэширование: увеличивается количество бакетов и все элменты перераспределяются



